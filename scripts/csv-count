#!/usr/bin/env python3

import argparse
import json
import os
import sys
import time
import datetime
import re
import csv
import glob

# Use local libraries first
libdir = os.path.join(os.path.dirname(os.path.abspath(__file__)),'lib','python')
if not os.path.isdir(libdir):
	print(f"WARNING: '{libdir}' is not a directory. You may have problems.")
else:
	sys.path.insert(0, libdir)
	pass

from misc.MyInfo import MyInfo,me


class ColumnData:
	def __init__(self,parent,idx):
		super().__init__()
		self.parent = parent
		self.idx = idx
		self.null_count = 0
		self.nan_count = 0
		self.one_count = 0
		self.zero_count = 0
		self.count = 0
		self.sum = 0
		self.column_num = idx + 1
		self.column_header = self.parent.idx2header[idx]
		pass

	def process(self,value_str):
		err = False
		self.count += 1
		if "" == value_str:
			self.null_count += 1
			return
		try:
			val = float(value_str)
			try:
				val = int(value_str)
			except ValueError as e:
				self.nan_count += 1
				err = True
				pass
		except ValueError as e:
			err = True
			pass
		if not err:
			if 0 == val:
				self.zero_count += 1
			elif 1 == val:
				self.one_count += 1
				pass
			self.sum += val
			pass
		return self

	def to_dict(self):
		data_dict = {
			"column_header":self.column_header,
			"column_index":self.idx,
			"column_num":self.column_num,
			"count":self.count,
			"nan_count":self.nan_count,
			"null_count":self.null_count,
			"one_count":self.one_count,
			"sum":self.sum,
			"zero_count":self.zero_count,
			}
		data_dict["numeric_count"] = data_dict["count"] - data_dict["nan_count"] - data_dict["null_count"]
		data_dict["nan_percent"] = data_dict["nan_count"] / data_dict["count"]
		data_dict["null_percent"] = data_dict["null_count"] / data_dict["count"]
		data_dict["zero_percent"] = data_dict["zero_count"] / data_dict["count"]
		data_dict["one_percent"] = data_dict["one_count"] / data_dict["count"]
		data_dict["percent_numeric_zero"] = data_dict["zero_count"] / data_dict["numeric_count"]
		data_dict["percent_numeric_one"] = data_dict["one_count"] / data_dict["numeric_count"]
		if data_dict["numeric_count"] < 1:
			data_dict["mean"] = None
		else:
			data_dict["mean"] = data_dict["sum"]/data_dict["numeric_count"]
			pass
		return data_dict
	pass

class InlineColStats(ProcInfo):
	def __init__(self,filename,args):
		self.filename = filename
		self.args = args
		pass

	def get_int(self,val,err_msg):
		try:
			intval = int(val)
			return intval
		except ValueError as e:
			self.errs.append(err_msg)
			pass
		return 0

	def debug(self,msg):
		if self.args.debug:
			print(msg)
			pass
		return self

	def _get_col_idx(self,header,err_msg):
		if header in self.header2idx:
			self.debug(f"Found '{header}' with idx={self.header2idx[header]}")
			return self.header2idx[header]
		return self.get_int(header,err_msg)

	def _get_col_idxs(self,header):
		if header in self.header2idx:
			self.debug(f"Found '{header}' with idx={self.header2idx[header]}")
			self.cols += [self.header2idx[header]]
			return self
		if "-" in header:
			start,end = header.split("-")
			self.debug(f"Split '{header}' into '{start}' and '{end}'")
			start = self._get_col_idx(start,f"Could not find a column with '{header}' as a header and could not convert '{start}' into an integer.")
			if header.endswith("-"):
				end = len(self.idx2header)
			else:
				end = self._get_col_idx(end,f"Could not find a column with '{header}' as a header and could not convert '{end}' into an integer.")
				pass
			if end > len(self.headers):
				self.errs.append(f"'{end}' is a non-existent column index (last one is '{len(self.headers)}'.")
				pass
			self.cols += list(range(start, end + 1))
			return self
		else:
			try:
				col_no = int(header)
				self.cols.append(col_no - 1)
			except ValueError as e:
				self.errs.append(f"Column '{header}' does not exist.")
				pass
			pass
		pass

	def _init_cols(self):
		self.errs = []
		self.cols = []
		if self.args.debug:
			print(f"Input Columns: {self.args.columns}")
			pass
		for header in self.args.columns:
			self._get_col_idxs(header)
			pass
		if self.args.debug:
			print(f"Calculated Columns: {self.cols}")
			pass
		if len(self.errs) > 0:
			print("ERROR: Some columns do not exist:")
			for err in self.errs:
				print(f" - ERROR: '{err}' does not exist.")
				pass
			sys.exit(2)
			pass
		return self

	def process(self):
		with open(self.filename,'r') as fh:
			self.fh = fh
			self.reader = csv.reader(fh)
			self.headers = next(self.reader)
			self.header2idx = {}
			self.idx2header = []
			idx = -1
			for header in self.headers:
				idx += 1
				self.header2idx[header] = idx
				self.idx2header.append(header)
				pass
			if self.args.list_columns:
				num = 0
				print(f"Col Num - Col Header")
				for header in self.headers:
					num += 1
					print(f"{num:7} - '{header}'")
					pass
				sys.exit(0)
				pass
			self._init_cols()
			self.process_lines()
			pass
		return self

	def process_lines(self):
		self.line_no = 0
		self.tp = self.now()
		self.data = []
		for idx in self.cols:
			self.data.append(ColumnData(self,idx))
			pass
		has_empties = False
		for row in self.reader:
			if(len(row) < 1):
				if not has_empties:
					self.debug("Skipping empty row(s)")
					has_empties = True
					pass
				continue
				pass
			self.line_no += 1
			self.debug(row)
			if 0 == self.line_no % self.args.record_tick_check:
				if self.elapsed(self.tp) >= self.args.progress_secs:
					secs = self.elapsed()
					print(f"{self.psecs(secs)} - {self.rate(self.line_no)}")
					pass
				pass
			data_idx = -1
			for idx in self.cols:
				data_idx += 1
				col_data = self.data[data_idx]
				try:
					col_data.process( row[idx] )
				except IndexError as e:
					print(f"ERROR: line {self.line_no} index {idx} is out of range  ({row})")
					exit(1)
				pass
			pass
		self.debug(f"self.args.output_csv='{self.args.output_csv}'")
		if self.args.output_csv is None:
			return self.show()
		return self.save_csv()

	def show(self):
		results = []
		for d in self.data:
			results.append(d.to_dict())
			pass
		print(json.dumps(results,indent=2,sort_keys=True))
		return self

	def save_csv(self):
		if self.args.verbosity >= 1:
			print("Saving '{self.args.output_csv}'")
			pass
		with open(self.args.output_csv,'w') as fh:
			writer = csv.DictWriter(fh,fieldnames = [
				"column_header",
				"column_index",
				"column_num",
				"count",
				"mean",
				"nan_count",
				"nan_percent",
				"null_count",
				"null_percent",
				"numeric_count",
				"one_count",
				"one_percent",
				"percent_numeric_one",
				"percent_numeric_zero",
				"sum",
				"zero_percent",
				"zero_count",
				])
			writer.writeheader()
			for d in self.data:
				writer.writerow(d.to_dict())
				pass
			pass
		return self
	pass

def main():
	parser = argparse.ArgumentParser(description='Build info about data from PushShift.io files.')
	parser.add_argument('columns', nargs='+', help="Columns to give info on.")
	parser.add_argument('--debug', '-d', default=False, action='store_true', dest='debug', help="Turn debugging on.")
	parser.add_argument('--list-columns', '-L', default=False, action='store_true', dest='list_columns', help="Show information on the columns (headers, indexes) and exit.")
	parser.add_argument('--input-csv', '-i', required=True, dest='input_file', help="Input CSV file.")
	parser.add_argument('--output-csv', '-o', default=None, dest='output_csv', help="Output CSV file (otherwise things are printed to STDOUT).")
	parser.add_argument('--record-tick-check', '-rt', default=10, dest='record_tick_check', type=int,help="Number of THOUSAND records before checking if --progress-secs has passed.")
	parser.add_argument('--progress-secs', '-ps', default=30, dest='progress_secs', type=int,help="Seconds before showing progress.")
	parser.add_argument('--quiet', '-q', default=0, dest='quiet', action='count',help="Decrease verbosity. Can have multiple.")
	parser.add_argument('--verbose', '-v', default=0, dest='verbosity', action='count',help="Increase verbosity. Can have multiple.")
	args = parser.parse_args()
	args.verbosity = 1 + args.verbosity - args.quiet
	args.record_tick_check = args.record_tick_check * 1000
	a = InlineColStats(args.input_file,args)
	a.process()
	pass

if __name__ == "__main__":
	main()
	sys.exit(0)
	pass
