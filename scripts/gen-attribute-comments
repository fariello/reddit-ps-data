#!/usr/bin/env python3

import json
import texttable
import collections

with open('meta-data/Reddit-2018-meta.json') as fh:
	data = json.load(fh)
	pass

class Base:
	def get(self,key,default=None,obj=None):
		if obj is None:
			obj = self.data
			pass
		if key in obj:
			return obj[key]
		return default

	def rget(self,keys,default=None,obj=None):
		if obj is None:
			obj = self.data
			pass
		if len(keys) > 1:
			if keys[0] in obj:
				return self.rget(keys[1:],default,obj[keys[0]])
			else:
				return default
			pass
		if keys[0] in obj:
			return obj[keys[0]]
		return default
	pass

class AttributeInfo(Base):
	def __init__(self,name,total,subs,coms,rec_count,attr_info):
		self.name = name
		self.total = total
		self.subs = subs
		self.coms = coms
		self.rec_count = rec_count
		self.data = attr_info
		self.count = self.data["count"]
		self.sub_count = self.get("submissions_count")
		self.com_count = self.get("comments_count")
		self.found_in = self.get("found_in")
		self.in_subs = self.sub_count > 0
		self.in_coms = self.com_count > 0
		vtypes = self.data["value_types"]
		self.type_info = {}
		self.val_by_type = {}
		for vtype in "null bool int float str list dict".split():
			self._type_info(vtype,self.get(vtype,default={},obj=vtypes))
			pass
		#print(json.dumps(self.type_info,indent=2,sort_keys=True))
		pass

	def print(self):
		self.text = "\n"
		self.text += "=" * 78 + "\n"
		self.text += f"ATTRIBUTE INFO for \"{attribute_name}\" from {subs} submissions and {coms} comments ({total} total).\n"
		self.text += "-" * 78 + "\n"
		self.pinfo()
		self.text += "\n"
		self.text += "-" * 78 + "\n"
		self.text += f"Unique Values for \"{attribute_name}\" from {subs} submissions and {coms} comments ({total} total).\n"
		self.text += "-" * 78 + "\n"
		self.puniqs()
		self.text += "\n"
		for line in self.text.splitlines():
			if len(line) > 0:
				print(f"# {line}")
			else:
				print("#")
				pass
			pass
		pass

	def pinfo(self):
		self.tt = texttable.Texttable()
		headers = [
			"Value\nType",
			"All\nCount",
			"All\nMin",
			"All\nMax",
			"All\nMean",
			"All\nUniq",
			"Subs\nCount",
			"Subs\nMin",
			"Subs\nMax",
			"Subs\nMean",
			"Subs\nUniq",
			"Coms\nCount",
			"Coms\nMin",
			"Coms\nMax",
			"Coms\nMean",
			"Coms\nUniq",
			]
		self.tt.set_deco(texttable.Texttable.HEADER)
		self.tt.header(headers)
		self.tt.set_cols_align(["l"] + ["r"] * (len(headers) - 1))
		self.tt.set_cols_dtype(["t"] * len(headers))
		self.tt.set_max_width(0)
		self.type_info["Missing"] = {}
		totals = {"sc":self.total,"sub":self.subs,"com":self.coms}
		for vtype in "null bool int float str list dict".split():
			for grp in ["sc","sub","com"]:
				for key in ["count","min","max","mean","unique_count"]:
					full_key = f"{grp}_{key}"
					if full_key not in self.type_info["Missing"]:
						if "count" == key:
							self.type_info["Missing"][full_key] = totals[grp]
						else:
							self.type_info["Missing"][full_key] = "-"
							pass
						pass
					elif "count" == key:
						if "-" != self.type_info[vtype][full_key]:
							self.type_info["Missing"][full_key] -= self.type_info[vtype][full_key]
							pass
						pass
					pass
				pass
			pass
		if 0 == self.type_info["Missing"]["sc_count"]:
			self.type_info["Missing"]["sc_count"] = "-"
			pass
		if 0 == self.type_info["Missing"]["sub_count"]:
			self.type_info["Missing"]["sub_count"] = "-"
			pass
		if 0 == self.type_info["Missing"]["com_count"]:
			self.type_info["Missing"]["com_count"] = "-"
			pass
		for vtype in "null bool int float str list dict Missing".split():
			row = [f"{vtype}"]
			for grp in ["sc","sub","com"]:
				for key in ["count","min","max","mean","unique_count"]:
					row += [self.type_info[vtype][f"{grp}_{key}"]]
					pass
				pass
			self.tt.add_row(row)
			pass
		self.text += self.tt.draw()
		pass

	def _count_uniq(self,key,default,obj):
		val = self.get(key,default=default,obj=obj)
		if "Too Many" == val:
			return val
		if val is None:
			return "-"
		return len(val.keys())

	def _get_mean(self,key_val,key_n,data):
		n = self.get(key_n,default=0,obj=data)
		if 0 == n:
			return "-"
		val = self.get(key_val,default=0,obj=data)
		return f"{val:0.2f}"

	def _sub_type_info(self,key,vtype,data,group_info):
		label = f"{key}"
		#print([key,vtype,data,group_info])
		preface = f"{group_info['preface']}"
		self.type_info[vtype][f"{label}_pretty"] = group_info['pretty']
		self.type_info[vtype][f"{label}_unique_count"] = self._count_uniq(f"{preface}unique_values",default=None,obj=data)
		count = self.get(f"{preface}count",default="-",obj=data)
		self.type_info[vtype][f"{label}_count"] = count
		self.type_info[vtype][f"{label}_min"] = self.get(f"{preface}min",default="-",obj=data)
		self.type_info[vtype][f"{label}_max"] = self.get(f"{preface}max",default="-",obj=data)
		if vtype in ["int","float"] and "-" != count:
			self.type_info[vtype][f"{label}_mean"] = "%0.2f" % (self.get(f"{preface}sum",default=0,obj=data) / count)
		else:
			self.type_info[vtype][f"{label}_mean"] = "-"
			pass
		if vtype in ["list","str"] and "-" != count:
			self.type_info[vtype][f"{label}_min"] = self.get(f"{preface}min_length",default="-",obj=data)
			self.type_info[vtype][f"{label}_max"] = self.get(f"{preface}max_length",default="-",obj=data)
			self.type_info[vtype][f"{label}_mean"] = "%0.2f" % (self.get(f"{preface}length_sum",default=0,obj=data) / count)
		else:
			self.type_info[vtype][f"{label}_mean"] = "-"
			pass
		#print(self.type_info[vtype])
		pass

	def _type_info(self,vtype,data):
		if vtype in self.type_info:
			raise ValueError(f"Duplicated vtype '{vtype}'")
		self.type_info[vtype] = {}
		groups = {
			"sc":{"preface":"","pretty":"All",},
			"com":{"preface":"comments_","pretty":"Coms",},
			"sub":{"preface":"submissions_","pretty":"Subs",},
		}
		#print(json.dumps(self.type_info,indent=2,sort_keys=True))
		for key,group_info in groups.items():
			self._sub_type_info(key,vtype,data,group_info)
			pass
		pass

	def _track_uniq(self,where,vtype,value,count):
		if "Too Many" == value:
			key = "Too Many"
		else:
			key = f"{vtype}: '{value}'"
			pass
		if key not in self.all_uniques:
			self.all_uniques[key] = {}
			pass
		if where in self.all_uniques[key] and "Too Many" != key:
			raise ValueError(f"Dupe: key='{key}' where='{where}' {self.all_uniques[key]}")
		self.all_uniques[key][where] = count
		pass

	def _track_uniqs(self,vtype,key,where,obj):
		uniques = self.get(key,default={},obj=obj)
		if "Too Many" == uniques:
			return self._track_uniq(where,vtype,"Too Many","?")
		for value,count in uniques.items():
			self._track_uniq(where,vtype,value,count)
			pass
		pass

	def _puniqs_text(self,key,sub_key):
		val = self.all_uniques[key][sub_key]
		#print([key,sub_key,val,self.total])
		if "-" != val and "?" != val:
			per = f"{val*100.0/self.total:0.2f}"
			return f"{val} / {per:>7s}%"
		return val

	def puniqs(self):
		self.tt = texttable.Texttable()
		headers = [
			"Value",
			"All",
			"In Submissions",
			"In Comments",
			]
		self.tt.set_deco(texttable.Texttable.HEADER)
		self.tt.header(headers)
		self.tt.set_cols_align(["l"] + ["r"] * (len(headers) - 1))
		self.tt.set_cols_dtype(["t"] * len(headers))
		self.tt.set_max_width(0)
		self.all_uniques = {}
		value_types = self.get("value_types")
		for vtype,data in value_types.items():
			self._track_uniqs(vtype,"unique_values","All",data)
			self._track_uniqs(vtype,"submissions_unique_values","Subs",data)
			self._track_uniqs(vtype,"comments_unique_values","Coms",data)
			pass
		for key,values in self.all_uniques.items():
			for where in ["All","Subs","Coms"]:
				if where not in self.all_uniques[key]:
					self.all_uniques[key][where] = "-"
					pass
				pass
			pass
		keys = sorted(self.all_uniques.keys())
		for key in keys:
			if "Too Many" == key:
				continue
			self.tt.add_row([
				key,
				self._puniqs_text(key,"All"),
				self._puniqs_text(key,"Subs"),
				self._puniqs_text(key,"Coms"),
				])
			pass
		self.text += self.tt.draw()
		pass

	pass

attribute_names = sorted(data["attributes"].keys())
total = data["object_count"] - 1 # Bug in originalcode counted one too many
subs = data["submissions_object_count"]
coms = data["comments_object_count"] - 1 # Bug in originalcode counted one too many
for attribute_name in attribute_names:
	attr_info = data["attributes"][attribute_name]
	count = attr_info["count"]
	ai = AttributeInfo(attribute_name,total,subs,coms,count,attr_info)
	ai.print()
	#exit()
	pass
